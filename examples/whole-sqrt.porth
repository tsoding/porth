include "std.porth"

// in : s n
// out: ((s // n) + n) // 2
// one iteration of the Babylonian method
macro _apply
  over over /
  over +
  2 /
  swap drop
  swap drop
end

// in : s
// out: floor(sqrt(s))
// uses Babylonian method
macro whole_sqrt
  if dup 1 = do  // 1 is a special case for Babylonian method
    drop 1  // sqrt(1) == 1
  else if dup 0 < do
    "\nValue error, input: " eputs dup print
    here eputs " Can't get sqrt from negative number" eputs 1 exit
  else  // general case
    dup  // `previous`
    dup 2 /  // `current` - firt guess
    while 2dup swap < do
      swap drop // we don't need `previous` anymore
      // dup print // debug
      2dup _apply // apply one iteration and get `current`
      // old `current` becomes `previous`
    end
    drop // drop `current`
    swap drop // drop `s`
    // leave `previous`
  end end
end

// in : number
// out: number == whole_sqrt(number)**2
macro is_perfect_square
  dup whole_sqrt dup * =
end

// test is_perfect_square
100 while dup -101 != do
  if dup is_perfect_square do
    "Perfect square: " puts dup print
  end
  1 -
end
drop
